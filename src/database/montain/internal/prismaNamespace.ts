
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models"
import { type PrismaClient } from "./class"

export type * from '../models'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.3.0
 * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
 */
export const prismaVersion: PrismaVersion = {
  client: "7.3.0",
  engine: "9d6ad21cbbceab97458517b147a6a09ff43aa735"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  Conf_EOQSTOK: 'Conf_EOQSTOK',
  dAddress: 'dAddress',
  dChannelOrder: 'dChannelOrder',
  dCode: 'dCode',
  dCommand: 'dCommand',
  dControl: 'dControl',
  dCustomer: 'dCustomer',
  dData: 'dData',
  dDepth: 'dDepth',
  dERP: 'dERP',
  dMeta: 'dMeta',
  dOrder: 'dOrder',
  dPage: 'dPage',
  dProduct: 'dProduct',
  dProductProperty: 'dProductProperty',
  dProductPropertyPivot: 'dProductPropertyPivot',
  dProperty: 'dProperty',
  dPurchaseOrder: 'dPurchaseOrder',
  dSalesOrder: 'dSalesOrder',
  dStation: 'dStation',
  dStock: 'dStock',
  dStockAudit: 'dStockAudit',
  dStockProperty: 'dStockProperty',
  dStockPropertyPivot: 'dStockPropertyPivot',
  dStorage: 'dStorage',
  dSupplier: 'dSupplier',
  dSync: 'dSync',
  dText: 'dText',
  dTransferOrder: 'dTransferOrder',
  dUser: 'dUser',
  dVendor: 'dVendor',
  dWorkOrder: 'dWorkOrder',
  ItemSage: 'ItemSage',
  SageName: 'SageName',
  SageVendor: 'SageVendor',
  sessions: 'sessions',
  StockCremora: 'StockCremora',
  sysdiagrams: 'sysdiagrams',
  tProperty: 'tProperty'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "conf_EOQSTOK" | "dAddress" | "dChannelOrder" | "dCode" | "dCommand" | "dControl" | "dCustomer" | "dData" | "dDepth" | "dERP" | "dMeta" | "dOrder" | "dPage" | "dProduct" | "dProductProperty" | "dProductPropertyPivot" | "dProperty" | "dPurchaseOrder" | "dSalesOrder" | "dStation" | "dStock" | "dStockAudit" | "dStockProperty" | "dStockPropertyPivot" | "dStorage" | "dSupplier" | "dSync" | "dText" | "dTransferOrder" | "dUser" | "dVendor" | "dWorkOrder" | "itemSage" | "sageName" | "sageVendor" | "sessions" | "stockCremora" | "sysdiagrams" | "tProperty"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    Conf_EOQSTOK: {
      payload: Prisma.$Conf_EOQSTOKPayload<ExtArgs>
      fields: Prisma.Conf_EOQSTOKFieldRefs
      operations: {
        findUnique: {
          args: Prisma.Conf_EOQSTOKFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Conf_EOQSTOKPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.Conf_EOQSTOKFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Conf_EOQSTOKPayload>
        }
        findFirst: {
          args: Prisma.Conf_EOQSTOKFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Conf_EOQSTOKPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.Conf_EOQSTOKFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Conf_EOQSTOKPayload>
        }
        findMany: {
          args: Prisma.Conf_EOQSTOKFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Conf_EOQSTOKPayload>[]
        }
        create: {
          args: Prisma.Conf_EOQSTOKCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Conf_EOQSTOKPayload>
        }
        createMany: {
          args: Prisma.Conf_EOQSTOKCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.Conf_EOQSTOKDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Conf_EOQSTOKPayload>
        }
        update: {
          args: Prisma.Conf_EOQSTOKUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Conf_EOQSTOKPayload>
        }
        deleteMany: {
          args: Prisma.Conf_EOQSTOKDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.Conf_EOQSTOKUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.Conf_EOQSTOKUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Conf_EOQSTOKPayload>
        }
        aggregate: {
          args: Prisma.Conf_EOQSTOKAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConf_EOQSTOK>
        }
        groupBy: {
          args: Prisma.Conf_EOQSTOKGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Conf_EOQSTOKGroupByOutputType>[]
        }
        count: {
          args: Prisma.Conf_EOQSTOKCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Conf_EOQSTOKCountAggregateOutputType> | number
        }
      }
    }
    dAddress: {
      payload: Prisma.$dAddressPayload<ExtArgs>
      fields: Prisma.dAddressFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dAddressFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dAddressPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dAddressFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dAddressPayload>
        }
        findFirst: {
          args: Prisma.dAddressFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dAddressPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dAddressFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dAddressPayload>
        }
        findMany: {
          args: Prisma.dAddressFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dAddressPayload>[]
        }
        create: {
          args: Prisma.dAddressCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dAddressPayload>
        }
        createMany: {
          args: Prisma.dAddressCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dAddressDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dAddressPayload>
        }
        update: {
          args: Prisma.dAddressUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dAddressPayload>
        }
        deleteMany: {
          args: Prisma.dAddressDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dAddressUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dAddressUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dAddressPayload>
        }
        aggregate: {
          args: Prisma.DAddressAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDAddress>
        }
        groupBy: {
          args: Prisma.dAddressGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DAddressGroupByOutputType>[]
        }
        count: {
          args: Prisma.dAddressCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DAddressCountAggregateOutputType> | number
        }
      }
    }
    dChannelOrder: {
      payload: Prisma.$dChannelOrderPayload<ExtArgs>
      fields: Prisma.dChannelOrderFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dChannelOrderFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dChannelOrderPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dChannelOrderFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dChannelOrderPayload>
        }
        findFirst: {
          args: Prisma.dChannelOrderFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dChannelOrderPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dChannelOrderFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dChannelOrderPayload>
        }
        findMany: {
          args: Prisma.dChannelOrderFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dChannelOrderPayload>[]
        }
        create: {
          args: Prisma.dChannelOrderCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dChannelOrderPayload>
        }
        createMany: {
          args: Prisma.dChannelOrderCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dChannelOrderDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dChannelOrderPayload>
        }
        update: {
          args: Prisma.dChannelOrderUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dChannelOrderPayload>
        }
        deleteMany: {
          args: Prisma.dChannelOrderDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dChannelOrderUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dChannelOrderUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dChannelOrderPayload>
        }
        aggregate: {
          args: Prisma.DChannelOrderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDChannelOrder>
        }
        groupBy: {
          args: Prisma.dChannelOrderGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DChannelOrderGroupByOutputType>[]
        }
        count: {
          args: Prisma.dChannelOrderCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DChannelOrderCountAggregateOutputType> | number
        }
      }
    }
    dCode: {
      payload: Prisma.$dCodePayload<ExtArgs>
      fields: Prisma.dCodeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dCodeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dCodePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dCodeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dCodePayload>
        }
        findFirst: {
          args: Prisma.dCodeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dCodePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dCodeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dCodePayload>
        }
        findMany: {
          args: Prisma.dCodeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dCodePayload>[]
        }
        create: {
          args: Prisma.dCodeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dCodePayload>
        }
        createMany: {
          args: Prisma.dCodeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dCodeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dCodePayload>
        }
        update: {
          args: Prisma.dCodeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dCodePayload>
        }
        deleteMany: {
          args: Prisma.dCodeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dCodeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dCodeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dCodePayload>
        }
        aggregate: {
          args: Prisma.DCodeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDCode>
        }
        groupBy: {
          args: Prisma.dCodeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DCodeGroupByOutputType>[]
        }
        count: {
          args: Prisma.dCodeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DCodeCountAggregateOutputType> | number
        }
      }
    }
    dCommand: {
      payload: Prisma.$dCommandPayload<ExtArgs>
      fields: Prisma.dCommandFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dCommandFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dCommandPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dCommandFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dCommandPayload>
        }
        findFirst: {
          args: Prisma.dCommandFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dCommandPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dCommandFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dCommandPayload>
        }
        findMany: {
          args: Prisma.dCommandFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dCommandPayload>[]
        }
        create: {
          args: Prisma.dCommandCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dCommandPayload>
        }
        createMany: {
          args: Prisma.dCommandCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dCommandDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dCommandPayload>
        }
        update: {
          args: Prisma.dCommandUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dCommandPayload>
        }
        deleteMany: {
          args: Prisma.dCommandDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dCommandUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dCommandUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dCommandPayload>
        }
        aggregate: {
          args: Prisma.DCommandAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDCommand>
        }
        groupBy: {
          args: Prisma.dCommandGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DCommandGroupByOutputType>[]
        }
        count: {
          args: Prisma.dCommandCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DCommandCountAggregateOutputType> | number
        }
      }
    }
    dControl: {
      payload: Prisma.$dControlPayload<ExtArgs>
      fields: Prisma.dControlFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dControlFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dControlPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dControlFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dControlPayload>
        }
        findFirst: {
          args: Prisma.dControlFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dControlPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dControlFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dControlPayload>
        }
        findMany: {
          args: Prisma.dControlFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dControlPayload>[]
        }
        create: {
          args: Prisma.dControlCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dControlPayload>
        }
        createMany: {
          args: Prisma.dControlCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dControlDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dControlPayload>
        }
        update: {
          args: Prisma.dControlUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dControlPayload>
        }
        deleteMany: {
          args: Prisma.dControlDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dControlUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dControlUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dControlPayload>
        }
        aggregate: {
          args: Prisma.DControlAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDControl>
        }
        groupBy: {
          args: Prisma.dControlGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DControlGroupByOutputType>[]
        }
        count: {
          args: Prisma.dControlCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DControlCountAggregateOutputType> | number
        }
      }
    }
    dCustomer: {
      payload: Prisma.$dCustomerPayload<ExtArgs>
      fields: Prisma.dCustomerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dCustomerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dCustomerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dCustomerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dCustomerPayload>
        }
        findFirst: {
          args: Prisma.dCustomerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dCustomerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dCustomerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dCustomerPayload>
        }
        findMany: {
          args: Prisma.dCustomerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dCustomerPayload>[]
        }
        create: {
          args: Prisma.dCustomerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dCustomerPayload>
        }
        createMany: {
          args: Prisma.dCustomerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dCustomerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dCustomerPayload>
        }
        update: {
          args: Prisma.dCustomerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dCustomerPayload>
        }
        deleteMany: {
          args: Prisma.dCustomerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dCustomerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dCustomerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dCustomerPayload>
        }
        aggregate: {
          args: Prisma.DCustomerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDCustomer>
        }
        groupBy: {
          args: Prisma.dCustomerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DCustomerGroupByOutputType>[]
        }
        count: {
          args: Prisma.dCustomerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DCustomerCountAggregateOutputType> | number
        }
      }
    }
    dData: {
      payload: Prisma.$dDataPayload<ExtArgs>
      fields: Prisma.dDataFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dDataFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dDataPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dDataFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dDataPayload>
        }
        findFirst: {
          args: Prisma.dDataFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dDataPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dDataFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dDataPayload>
        }
        findMany: {
          args: Prisma.dDataFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dDataPayload>[]
        }
        create: {
          args: Prisma.dDataCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dDataPayload>
        }
        createMany: {
          args: Prisma.dDataCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dDataDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dDataPayload>
        }
        update: {
          args: Prisma.dDataUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dDataPayload>
        }
        deleteMany: {
          args: Prisma.dDataDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dDataUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dDataUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dDataPayload>
        }
        aggregate: {
          args: Prisma.DDataAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDData>
        }
        groupBy: {
          args: Prisma.dDataGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DDataGroupByOutputType>[]
        }
        count: {
          args: Prisma.dDataCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DDataCountAggregateOutputType> | number
        }
      }
    }
    dDepth: {
      payload: Prisma.$dDepthPayload<ExtArgs>
      fields: Prisma.dDepthFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dDepthFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dDepthPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dDepthFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dDepthPayload>
        }
        findFirst: {
          args: Prisma.dDepthFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dDepthPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dDepthFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dDepthPayload>
        }
        findMany: {
          args: Prisma.dDepthFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dDepthPayload>[]
        }
        create: {
          args: Prisma.dDepthCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dDepthPayload>
        }
        createMany: {
          args: Prisma.dDepthCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dDepthDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dDepthPayload>
        }
        update: {
          args: Prisma.dDepthUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dDepthPayload>
        }
        deleteMany: {
          args: Prisma.dDepthDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dDepthUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dDepthUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dDepthPayload>
        }
        aggregate: {
          args: Prisma.DDepthAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDDepth>
        }
        groupBy: {
          args: Prisma.dDepthGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DDepthGroupByOutputType>[]
        }
        count: {
          args: Prisma.dDepthCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DDepthCountAggregateOutputType> | number
        }
      }
    }
    dERP: {
      payload: Prisma.$dERPPayload<ExtArgs>
      fields: Prisma.dERPFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dERPFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dERPPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dERPFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dERPPayload>
        }
        findFirst: {
          args: Prisma.dERPFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dERPPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dERPFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dERPPayload>
        }
        findMany: {
          args: Prisma.dERPFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dERPPayload>[]
        }
        create: {
          args: Prisma.dERPCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dERPPayload>
        }
        createMany: {
          args: Prisma.dERPCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dERPDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dERPPayload>
        }
        update: {
          args: Prisma.dERPUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dERPPayload>
        }
        deleteMany: {
          args: Prisma.dERPDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dERPUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dERPUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dERPPayload>
        }
        aggregate: {
          args: Prisma.DERPAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDERP>
        }
        groupBy: {
          args: Prisma.dERPGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DERPGroupByOutputType>[]
        }
        count: {
          args: Prisma.dERPCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DERPCountAggregateOutputType> | number
        }
      }
    }
    dMeta: {
      payload: Prisma.$dMetaPayload<ExtArgs>
      fields: Prisma.dMetaFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dMetaFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dMetaPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dMetaFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dMetaPayload>
        }
        findFirst: {
          args: Prisma.dMetaFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dMetaPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dMetaFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dMetaPayload>
        }
        findMany: {
          args: Prisma.dMetaFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dMetaPayload>[]
        }
        create: {
          args: Prisma.dMetaCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dMetaPayload>
        }
        createMany: {
          args: Prisma.dMetaCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dMetaDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dMetaPayload>
        }
        update: {
          args: Prisma.dMetaUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dMetaPayload>
        }
        deleteMany: {
          args: Prisma.dMetaDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dMetaUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dMetaUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dMetaPayload>
        }
        aggregate: {
          args: Prisma.DMetaAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDMeta>
        }
        groupBy: {
          args: Prisma.dMetaGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DMetaGroupByOutputType>[]
        }
        count: {
          args: Prisma.dMetaCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DMetaCountAggregateOutputType> | number
        }
      }
    }
    dOrder: {
      payload: Prisma.$dOrderPayload<ExtArgs>
      fields: Prisma.dOrderFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dOrderFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dOrderPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dOrderFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dOrderPayload>
        }
        findFirst: {
          args: Prisma.dOrderFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dOrderPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dOrderFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dOrderPayload>
        }
        findMany: {
          args: Prisma.dOrderFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dOrderPayload>[]
        }
        create: {
          args: Prisma.dOrderCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dOrderPayload>
        }
        createMany: {
          args: Prisma.dOrderCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dOrderDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dOrderPayload>
        }
        update: {
          args: Prisma.dOrderUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dOrderPayload>
        }
        deleteMany: {
          args: Prisma.dOrderDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dOrderUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dOrderUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dOrderPayload>
        }
        aggregate: {
          args: Prisma.DOrderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDOrder>
        }
        groupBy: {
          args: Prisma.dOrderGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DOrderGroupByOutputType>[]
        }
        count: {
          args: Prisma.dOrderCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DOrderCountAggregateOutputType> | number
        }
      }
    }
    dPage: {
      payload: Prisma.$dPagePayload<ExtArgs>
      fields: Prisma.dPageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dPageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dPagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dPageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dPagePayload>
        }
        findFirst: {
          args: Prisma.dPageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dPagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dPageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dPagePayload>
        }
        findMany: {
          args: Prisma.dPageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dPagePayload>[]
        }
        create: {
          args: Prisma.dPageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dPagePayload>
        }
        createMany: {
          args: Prisma.dPageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dPageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dPagePayload>
        }
        update: {
          args: Prisma.dPageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dPagePayload>
        }
        deleteMany: {
          args: Prisma.dPageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dPageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dPageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dPagePayload>
        }
        aggregate: {
          args: Prisma.DPageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDPage>
        }
        groupBy: {
          args: Prisma.dPageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DPageGroupByOutputType>[]
        }
        count: {
          args: Prisma.dPageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DPageCountAggregateOutputType> | number
        }
      }
    }
    dProduct: {
      payload: Prisma.$dProductPayload<ExtArgs>
      fields: Prisma.dProductFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dProductFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dProductPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dProductFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dProductPayload>
        }
        findFirst: {
          args: Prisma.dProductFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dProductPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dProductFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dProductPayload>
        }
        findMany: {
          args: Prisma.dProductFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dProductPayload>[]
        }
        create: {
          args: Prisma.dProductCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dProductPayload>
        }
        createMany: {
          args: Prisma.dProductCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dProductDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dProductPayload>
        }
        update: {
          args: Prisma.dProductUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dProductPayload>
        }
        deleteMany: {
          args: Prisma.dProductDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dProductUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dProductUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dProductPayload>
        }
        aggregate: {
          args: Prisma.DProductAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDProduct>
        }
        groupBy: {
          args: Prisma.dProductGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DProductGroupByOutputType>[]
        }
        count: {
          args: Prisma.dProductCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DProductCountAggregateOutputType> | number
        }
      }
    }
    dProductProperty: {
      payload: Prisma.$dProductPropertyPayload<ExtArgs>
      fields: Prisma.dProductPropertyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dProductPropertyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dProductPropertyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dProductPropertyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dProductPropertyPayload>
        }
        findFirst: {
          args: Prisma.dProductPropertyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dProductPropertyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dProductPropertyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dProductPropertyPayload>
        }
        findMany: {
          args: Prisma.dProductPropertyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dProductPropertyPayload>[]
        }
        create: {
          args: Prisma.dProductPropertyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dProductPropertyPayload>
        }
        createMany: {
          args: Prisma.dProductPropertyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dProductPropertyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dProductPropertyPayload>
        }
        update: {
          args: Prisma.dProductPropertyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dProductPropertyPayload>
        }
        deleteMany: {
          args: Prisma.dProductPropertyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dProductPropertyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dProductPropertyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dProductPropertyPayload>
        }
        aggregate: {
          args: Prisma.DProductPropertyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDProductProperty>
        }
        groupBy: {
          args: Prisma.dProductPropertyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DProductPropertyGroupByOutputType>[]
        }
        count: {
          args: Prisma.dProductPropertyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DProductPropertyCountAggregateOutputType> | number
        }
      }
    }
    dProductPropertyPivot: {
      payload: Prisma.$dProductPropertyPivotPayload<ExtArgs>
      fields: Prisma.dProductPropertyPivotFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dProductPropertyPivotFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dProductPropertyPivotPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dProductPropertyPivotFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dProductPropertyPivotPayload>
        }
        findFirst: {
          args: Prisma.dProductPropertyPivotFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dProductPropertyPivotPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dProductPropertyPivotFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dProductPropertyPivotPayload>
        }
        findMany: {
          args: Prisma.dProductPropertyPivotFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dProductPropertyPivotPayload>[]
        }
        create: {
          args: Prisma.dProductPropertyPivotCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dProductPropertyPivotPayload>
        }
        createMany: {
          args: Prisma.dProductPropertyPivotCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dProductPropertyPivotDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dProductPropertyPivotPayload>
        }
        update: {
          args: Prisma.dProductPropertyPivotUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dProductPropertyPivotPayload>
        }
        deleteMany: {
          args: Prisma.dProductPropertyPivotDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dProductPropertyPivotUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dProductPropertyPivotUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dProductPropertyPivotPayload>
        }
        aggregate: {
          args: Prisma.DProductPropertyPivotAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDProductPropertyPivot>
        }
        groupBy: {
          args: Prisma.dProductPropertyPivotGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DProductPropertyPivotGroupByOutputType>[]
        }
        count: {
          args: Prisma.dProductPropertyPivotCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DProductPropertyPivotCountAggregateOutputType> | number
        }
      }
    }
    dProperty: {
      payload: Prisma.$dPropertyPayload<ExtArgs>
      fields: Prisma.dPropertyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dPropertyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dPropertyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dPropertyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dPropertyPayload>
        }
        findFirst: {
          args: Prisma.dPropertyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dPropertyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dPropertyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dPropertyPayload>
        }
        findMany: {
          args: Prisma.dPropertyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dPropertyPayload>[]
        }
        create: {
          args: Prisma.dPropertyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dPropertyPayload>
        }
        createMany: {
          args: Prisma.dPropertyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dPropertyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dPropertyPayload>
        }
        update: {
          args: Prisma.dPropertyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dPropertyPayload>
        }
        deleteMany: {
          args: Prisma.dPropertyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dPropertyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dPropertyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dPropertyPayload>
        }
        aggregate: {
          args: Prisma.DPropertyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDProperty>
        }
        groupBy: {
          args: Prisma.dPropertyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DPropertyGroupByOutputType>[]
        }
        count: {
          args: Prisma.dPropertyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DPropertyCountAggregateOutputType> | number
        }
      }
    }
    dPurchaseOrder: {
      payload: Prisma.$dPurchaseOrderPayload<ExtArgs>
      fields: Prisma.dPurchaseOrderFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dPurchaseOrderFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dPurchaseOrderPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dPurchaseOrderFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dPurchaseOrderPayload>
        }
        findFirst: {
          args: Prisma.dPurchaseOrderFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dPurchaseOrderPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dPurchaseOrderFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dPurchaseOrderPayload>
        }
        findMany: {
          args: Prisma.dPurchaseOrderFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dPurchaseOrderPayload>[]
        }
        create: {
          args: Prisma.dPurchaseOrderCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dPurchaseOrderPayload>
        }
        createMany: {
          args: Prisma.dPurchaseOrderCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dPurchaseOrderDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dPurchaseOrderPayload>
        }
        update: {
          args: Prisma.dPurchaseOrderUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dPurchaseOrderPayload>
        }
        deleteMany: {
          args: Prisma.dPurchaseOrderDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dPurchaseOrderUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dPurchaseOrderUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dPurchaseOrderPayload>
        }
        aggregate: {
          args: Prisma.DPurchaseOrderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDPurchaseOrder>
        }
        groupBy: {
          args: Prisma.dPurchaseOrderGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DPurchaseOrderGroupByOutputType>[]
        }
        count: {
          args: Prisma.dPurchaseOrderCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DPurchaseOrderCountAggregateOutputType> | number
        }
      }
    }
    dSalesOrder: {
      payload: Prisma.$dSalesOrderPayload<ExtArgs>
      fields: Prisma.dSalesOrderFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dSalesOrderFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dSalesOrderPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dSalesOrderFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dSalesOrderPayload>
        }
        findFirst: {
          args: Prisma.dSalesOrderFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dSalesOrderPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dSalesOrderFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dSalesOrderPayload>
        }
        findMany: {
          args: Prisma.dSalesOrderFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dSalesOrderPayload>[]
        }
        create: {
          args: Prisma.dSalesOrderCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dSalesOrderPayload>
        }
        createMany: {
          args: Prisma.dSalesOrderCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dSalesOrderDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dSalesOrderPayload>
        }
        update: {
          args: Prisma.dSalesOrderUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dSalesOrderPayload>
        }
        deleteMany: {
          args: Prisma.dSalesOrderDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dSalesOrderUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dSalesOrderUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dSalesOrderPayload>
        }
        aggregate: {
          args: Prisma.DSalesOrderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDSalesOrder>
        }
        groupBy: {
          args: Prisma.dSalesOrderGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DSalesOrderGroupByOutputType>[]
        }
        count: {
          args: Prisma.dSalesOrderCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DSalesOrderCountAggregateOutputType> | number
        }
      }
    }
    dStation: {
      payload: Prisma.$dStationPayload<ExtArgs>
      fields: Prisma.dStationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dStationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dStationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStationPayload>
        }
        findFirst: {
          args: Prisma.dStationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dStationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStationPayload>
        }
        findMany: {
          args: Prisma.dStationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStationPayload>[]
        }
        create: {
          args: Prisma.dStationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStationPayload>
        }
        createMany: {
          args: Prisma.dStationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dStationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStationPayload>
        }
        update: {
          args: Prisma.dStationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStationPayload>
        }
        deleteMany: {
          args: Prisma.dStationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dStationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dStationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStationPayload>
        }
        aggregate: {
          args: Prisma.DStationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDStation>
        }
        groupBy: {
          args: Prisma.dStationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DStationGroupByOutputType>[]
        }
        count: {
          args: Prisma.dStationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DStationCountAggregateOutputType> | number
        }
      }
    }
    dStock: {
      payload: Prisma.$dStockPayload<ExtArgs>
      fields: Prisma.dStockFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dStockFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dStockFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockPayload>
        }
        findFirst: {
          args: Prisma.dStockFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dStockFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockPayload>
        }
        findMany: {
          args: Prisma.dStockFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockPayload>[]
        }
        create: {
          args: Prisma.dStockCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockPayload>
        }
        createMany: {
          args: Prisma.dStockCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dStockDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockPayload>
        }
        update: {
          args: Prisma.dStockUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockPayload>
        }
        deleteMany: {
          args: Prisma.dStockDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dStockUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dStockUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockPayload>
        }
        aggregate: {
          args: Prisma.DStockAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDStock>
        }
        groupBy: {
          args: Prisma.dStockGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DStockGroupByOutputType>[]
        }
        count: {
          args: Prisma.dStockCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DStockCountAggregateOutputType> | number
        }
      }
    }
    dStockAudit: {
      payload: Prisma.$dStockAuditPayload<ExtArgs>
      fields: Prisma.dStockAuditFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dStockAuditFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockAuditPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dStockAuditFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockAuditPayload>
        }
        findFirst: {
          args: Prisma.dStockAuditFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockAuditPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dStockAuditFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockAuditPayload>
        }
        findMany: {
          args: Prisma.dStockAuditFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockAuditPayload>[]
        }
        create: {
          args: Prisma.dStockAuditCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockAuditPayload>
        }
        createMany: {
          args: Prisma.dStockAuditCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dStockAuditDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockAuditPayload>
        }
        update: {
          args: Prisma.dStockAuditUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockAuditPayload>
        }
        deleteMany: {
          args: Prisma.dStockAuditDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dStockAuditUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dStockAuditUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockAuditPayload>
        }
        aggregate: {
          args: Prisma.DStockAuditAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDStockAudit>
        }
        groupBy: {
          args: Prisma.dStockAuditGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DStockAuditGroupByOutputType>[]
        }
        count: {
          args: Prisma.dStockAuditCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DStockAuditCountAggregateOutputType> | number
        }
      }
    }
    dStockProperty: {
      payload: Prisma.$dStockPropertyPayload<ExtArgs>
      fields: Prisma.dStockPropertyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dStockPropertyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockPropertyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dStockPropertyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockPropertyPayload>
        }
        findFirst: {
          args: Prisma.dStockPropertyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockPropertyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dStockPropertyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockPropertyPayload>
        }
        findMany: {
          args: Prisma.dStockPropertyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockPropertyPayload>[]
        }
        create: {
          args: Prisma.dStockPropertyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockPropertyPayload>
        }
        createMany: {
          args: Prisma.dStockPropertyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dStockPropertyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockPropertyPayload>
        }
        update: {
          args: Prisma.dStockPropertyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockPropertyPayload>
        }
        deleteMany: {
          args: Prisma.dStockPropertyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dStockPropertyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dStockPropertyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockPropertyPayload>
        }
        aggregate: {
          args: Prisma.DStockPropertyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDStockProperty>
        }
        groupBy: {
          args: Prisma.dStockPropertyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DStockPropertyGroupByOutputType>[]
        }
        count: {
          args: Prisma.dStockPropertyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DStockPropertyCountAggregateOutputType> | number
        }
      }
    }
    dStockPropertyPivot: {
      payload: Prisma.$dStockPropertyPivotPayload<ExtArgs>
      fields: Prisma.dStockPropertyPivotFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dStockPropertyPivotFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockPropertyPivotPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dStockPropertyPivotFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockPropertyPivotPayload>
        }
        findFirst: {
          args: Prisma.dStockPropertyPivotFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockPropertyPivotPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dStockPropertyPivotFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockPropertyPivotPayload>
        }
        findMany: {
          args: Prisma.dStockPropertyPivotFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockPropertyPivotPayload>[]
        }
        create: {
          args: Prisma.dStockPropertyPivotCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockPropertyPivotPayload>
        }
        createMany: {
          args: Prisma.dStockPropertyPivotCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dStockPropertyPivotDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockPropertyPivotPayload>
        }
        update: {
          args: Prisma.dStockPropertyPivotUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockPropertyPivotPayload>
        }
        deleteMany: {
          args: Prisma.dStockPropertyPivotDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dStockPropertyPivotUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dStockPropertyPivotUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStockPropertyPivotPayload>
        }
        aggregate: {
          args: Prisma.DStockPropertyPivotAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDStockPropertyPivot>
        }
        groupBy: {
          args: Prisma.dStockPropertyPivotGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DStockPropertyPivotGroupByOutputType>[]
        }
        count: {
          args: Prisma.dStockPropertyPivotCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DStockPropertyPivotCountAggregateOutputType> | number
        }
      }
    }
    dStorage: {
      payload: Prisma.$dStoragePayload<ExtArgs>
      fields: Prisma.dStorageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dStorageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStoragePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dStorageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStoragePayload>
        }
        findFirst: {
          args: Prisma.dStorageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStoragePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dStorageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStoragePayload>
        }
        findMany: {
          args: Prisma.dStorageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStoragePayload>[]
        }
        create: {
          args: Prisma.dStorageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStoragePayload>
        }
        createMany: {
          args: Prisma.dStorageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dStorageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStoragePayload>
        }
        update: {
          args: Prisma.dStorageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStoragePayload>
        }
        deleteMany: {
          args: Prisma.dStorageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dStorageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dStorageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dStoragePayload>
        }
        aggregate: {
          args: Prisma.DStorageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDStorage>
        }
        groupBy: {
          args: Prisma.dStorageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DStorageGroupByOutputType>[]
        }
        count: {
          args: Prisma.dStorageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DStorageCountAggregateOutputType> | number
        }
      }
    }
    dSupplier: {
      payload: Prisma.$dSupplierPayload<ExtArgs>
      fields: Prisma.dSupplierFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dSupplierFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dSupplierPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dSupplierFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dSupplierPayload>
        }
        findFirst: {
          args: Prisma.dSupplierFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dSupplierPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dSupplierFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dSupplierPayload>
        }
        findMany: {
          args: Prisma.dSupplierFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dSupplierPayload>[]
        }
        create: {
          args: Prisma.dSupplierCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dSupplierPayload>
        }
        createMany: {
          args: Prisma.dSupplierCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dSupplierDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dSupplierPayload>
        }
        update: {
          args: Prisma.dSupplierUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dSupplierPayload>
        }
        deleteMany: {
          args: Prisma.dSupplierDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dSupplierUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dSupplierUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dSupplierPayload>
        }
        aggregate: {
          args: Prisma.DSupplierAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDSupplier>
        }
        groupBy: {
          args: Prisma.dSupplierGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DSupplierGroupByOutputType>[]
        }
        count: {
          args: Prisma.dSupplierCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DSupplierCountAggregateOutputType> | number
        }
      }
    }
    dSync: {
      payload: Prisma.$dSyncPayload<ExtArgs>
      fields: Prisma.dSyncFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dSyncFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dSyncPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dSyncFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dSyncPayload>
        }
        findFirst: {
          args: Prisma.dSyncFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dSyncPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dSyncFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dSyncPayload>
        }
        findMany: {
          args: Prisma.dSyncFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dSyncPayload>[]
        }
        create: {
          args: Prisma.dSyncCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dSyncPayload>
        }
        createMany: {
          args: Prisma.dSyncCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dSyncDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dSyncPayload>
        }
        update: {
          args: Prisma.dSyncUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dSyncPayload>
        }
        deleteMany: {
          args: Prisma.dSyncDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dSyncUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dSyncUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dSyncPayload>
        }
        aggregate: {
          args: Prisma.DSyncAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDSync>
        }
        groupBy: {
          args: Prisma.dSyncGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DSyncGroupByOutputType>[]
        }
        count: {
          args: Prisma.dSyncCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DSyncCountAggregateOutputType> | number
        }
      }
    }
    dText: {
      payload: Prisma.$dTextPayload<ExtArgs>
      fields: Prisma.dTextFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dTextFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dTextPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dTextFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dTextPayload>
        }
        findFirst: {
          args: Prisma.dTextFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dTextPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dTextFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dTextPayload>
        }
        findMany: {
          args: Prisma.dTextFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dTextPayload>[]
        }
        create: {
          args: Prisma.dTextCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dTextPayload>
        }
        createMany: {
          args: Prisma.dTextCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dTextDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dTextPayload>
        }
        update: {
          args: Prisma.dTextUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dTextPayload>
        }
        deleteMany: {
          args: Prisma.dTextDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dTextUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dTextUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dTextPayload>
        }
        aggregate: {
          args: Prisma.DTextAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDText>
        }
        groupBy: {
          args: Prisma.dTextGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DTextGroupByOutputType>[]
        }
        count: {
          args: Prisma.dTextCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DTextCountAggregateOutputType> | number
        }
      }
    }
    dTransferOrder: {
      payload: Prisma.$dTransferOrderPayload<ExtArgs>
      fields: Prisma.dTransferOrderFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dTransferOrderFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dTransferOrderPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dTransferOrderFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dTransferOrderPayload>
        }
        findFirst: {
          args: Prisma.dTransferOrderFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dTransferOrderPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dTransferOrderFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dTransferOrderPayload>
        }
        findMany: {
          args: Prisma.dTransferOrderFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dTransferOrderPayload>[]
        }
        create: {
          args: Prisma.dTransferOrderCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dTransferOrderPayload>
        }
        createMany: {
          args: Prisma.dTransferOrderCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dTransferOrderDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dTransferOrderPayload>
        }
        update: {
          args: Prisma.dTransferOrderUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dTransferOrderPayload>
        }
        deleteMany: {
          args: Prisma.dTransferOrderDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dTransferOrderUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dTransferOrderUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dTransferOrderPayload>
        }
        aggregate: {
          args: Prisma.DTransferOrderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDTransferOrder>
        }
        groupBy: {
          args: Prisma.dTransferOrderGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DTransferOrderGroupByOutputType>[]
        }
        count: {
          args: Prisma.dTransferOrderCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DTransferOrderCountAggregateOutputType> | number
        }
      }
    }
    dUser: {
      payload: Prisma.$dUserPayload<ExtArgs>
      fields: Prisma.dUserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dUserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dUserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dUserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dUserPayload>
        }
        findFirst: {
          args: Prisma.dUserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dUserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dUserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dUserPayload>
        }
        findMany: {
          args: Prisma.dUserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dUserPayload>[]
        }
        create: {
          args: Prisma.dUserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dUserPayload>
        }
        createMany: {
          args: Prisma.dUserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dUserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dUserPayload>
        }
        update: {
          args: Prisma.dUserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dUserPayload>
        }
        deleteMany: {
          args: Prisma.dUserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dUserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dUserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dUserPayload>
        }
        aggregate: {
          args: Prisma.DUserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDUser>
        }
        groupBy: {
          args: Prisma.dUserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DUserGroupByOutputType>[]
        }
        count: {
          args: Prisma.dUserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DUserCountAggregateOutputType> | number
        }
      }
    }
    dVendor: {
      payload: Prisma.$dVendorPayload<ExtArgs>
      fields: Prisma.dVendorFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dVendorFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dVendorPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dVendorFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dVendorPayload>
        }
        findFirst: {
          args: Prisma.dVendorFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dVendorPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dVendorFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dVendorPayload>
        }
        findMany: {
          args: Prisma.dVendorFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dVendorPayload>[]
        }
        create: {
          args: Prisma.dVendorCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dVendorPayload>
        }
        createMany: {
          args: Prisma.dVendorCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dVendorDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dVendorPayload>
        }
        update: {
          args: Prisma.dVendorUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dVendorPayload>
        }
        deleteMany: {
          args: Prisma.dVendorDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dVendorUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dVendorUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dVendorPayload>
        }
        aggregate: {
          args: Prisma.DVendorAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDVendor>
        }
        groupBy: {
          args: Prisma.dVendorGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DVendorGroupByOutputType>[]
        }
        count: {
          args: Prisma.dVendorCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DVendorCountAggregateOutputType> | number
        }
      }
    }
    dWorkOrder: {
      payload: Prisma.$dWorkOrderPayload<ExtArgs>
      fields: Prisma.dWorkOrderFieldRefs
      operations: {
        findUnique: {
          args: Prisma.dWorkOrderFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dWorkOrderPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.dWorkOrderFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dWorkOrderPayload>
        }
        findFirst: {
          args: Prisma.dWorkOrderFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dWorkOrderPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.dWorkOrderFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dWorkOrderPayload>
        }
        findMany: {
          args: Prisma.dWorkOrderFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dWorkOrderPayload>[]
        }
        create: {
          args: Prisma.dWorkOrderCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dWorkOrderPayload>
        }
        createMany: {
          args: Prisma.dWorkOrderCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.dWorkOrderDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dWorkOrderPayload>
        }
        update: {
          args: Prisma.dWorkOrderUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dWorkOrderPayload>
        }
        deleteMany: {
          args: Prisma.dWorkOrderDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.dWorkOrderUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.dWorkOrderUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$dWorkOrderPayload>
        }
        aggregate: {
          args: Prisma.DWorkOrderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDWorkOrder>
        }
        groupBy: {
          args: Prisma.dWorkOrderGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DWorkOrderGroupByOutputType>[]
        }
        count: {
          args: Prisma.dWorkOrderCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DWorkOrderCountAggregateOutputType> | number
        }
      }
    }
    ItemSage: {
      payload: Prisma.$ItemSagePayload<ExtArgs>
      fields: Prisma.ItemSageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ItemSageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemSagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ItemSageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemSagePayload>
        }
        findFirst: {
          args: Prisma.ItemSageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemSagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ItemSageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemSagePayload>
        }
        findMany: {
          args: Prisma.ItemSageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemSagePayload>[]
        }
        create: {
          args: Prisma.ItemSageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemSagePayload>
        }
        createMany: {
          args: Prisma.ItemSageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ItemSageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemSagePayload>
        }
        update: {
          args: Prisma.ItemSageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemSagePayload>
        }
        deleteMany: {
          args: Prisma.ItemSageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ItemSageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ItemSageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ItemSagePayload>
        }
        aggregate: {
          args: Prisma.ItemSageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateItemSage>
        }
        groupBy: {
          args: Prisma.ItemSageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ItemSageGroupByOutputType>[]
        }
        count: {
          args: Prisma.ItemSageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ItemSageCountAggregateOutputType> | number
        }
      }
    }
    SageName: {
      payload: Prisma.$SageNamePayload<ExtArgs>
      fields: Prisma.SageNameFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SageNameFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SageNamePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SageNameFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SageNamePayload>
        }
        findFirst: {
          args: Prisma.SageNameFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SageNamePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SageNameFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SageNamePayload>
        }
        findMany: {
          args: Prisma.SageNameFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SageNamePayload>[]
        }
        create: {
          args: Prisma.SageNameCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SageNamePayload>
        }
        createMany: {
          args: Prisma.SageNameCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.SageNameDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SageNamePayload>
        }
        update: {
          args: Prisma.SageNameUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SageNamePayload>
        }
        deleteMany: {
          args: Prisma.SageNameDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SageNameUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.SageNameUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SageNamePayload>
        }
        aggregate: {
          args: Prisma.SageNameAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSageName>
        }
        groupBy: {
          args: Prisma.SageNameGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SageNameGroupByOutputType>[]
        }
        count: {
          args: Prisma.SageNameCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SageNameCountAggregateOutputType> | number
        }
      }
    }
    SageVendor: {
      payload: Prisma.$SageVendorPayload<ExtArgs>
      fields: Prisma.SageVendorFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SageVendorFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SageVendorPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SageVendorFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SageVendorPayload>
        }
        findFirst: {
          args: Prisma.SageVendorFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SageVendorPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SageVendorFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SageVendorPayload>
        }
        findMany: {
          args: Prisma.SageVendorFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SageVendorPayload>[]
        }
        create: {
          args: Prisma.SageVendorCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SageVendorPayload>
        }
        createMany: {
          args: Prisma.SageVendorCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.SageVendorDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SageVendorPayload>
        }
        update: {
          args: Prisma.SageVendorUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SageVendorPayload>
        }
        deleteMany: {
          args: Prisma.SageVendorDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SageVendorUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.SageVendorUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SageVendorPayload>
        }
        aggregate: {
          args: Prisma.SageVendorAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSageVendor>
        }
        groupBy: {
          args: Prisma.SageVendorGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SageVendorGroupByOutputType>[]
        }
        count: {
          args: Prisma.SageVendorCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SageVendorCountAggregateOutputType> | number
        }
      }
    }
    sessions: {
      payload: Prisma.$sessionsPayload<ExtArgs>
      fields: Prisma.sessionsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.sessionsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.sessionsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionsPayload>
        }
        findFirst: {
          args: Prisma.sessionsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.sessionsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionsPayload>
        }
        findMany: {
          args: Prisma.sessionsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionsPayload>[]
        }
        create: {
          args: Prisma.sessionsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionsPayload>
        }
        createMany: {
          args: Prisma.sessionsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.sessionsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionsPayload>
        }
        update: {
          args: Prisma.sessionsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionsPayload>
        }
        deleteMany: {
          args: Prisma.sessionsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.sessionsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.sessionsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sessionsPayload>
        }
        aggregate: {
          args: Prisma.SessionsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSessions>
        }
        groupBy: {
          args: Prisma.sessionsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionsGroupByOutputType>[]
        }
        count: {
          args: Prisma.sessionsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionsCountAggregateOutputType> | number
        }
      }
    }
    StockCremora: {
      payload: Prisma.$StockCremoraPayload<ExtArgs>
      fields: Prisma.StockCremoraFieldRefs
      operations: {
        findUnique: {
          args: Prisma.StockCremoraFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockCremoraPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.StockCremoraFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockCremoraPayload>
        }
        findFirst: {
          args: Prisma.StockCremoraFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockCremoraPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.StockCremoraFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockCremoraPayload>
        }
        findMany: {
          args: Prisma.StockCremoraFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockCremoraPayload>[]
        }
        create: {
          args: Prisma.StockCremoraCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockCremoraPayload>
        }
        createMany: {
          args: Prisma.StockCremoraCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.StockCremoraDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockCremoraPayload>
        }
        update: {
          args: Prisma.StockCremoraUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockCremoraPayload>
        }
        deleteMany: {
          args: Prisma.StockCremoraDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.StockCremoraUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.StockCremoraUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockCremoraPayload>
        }
        aggregate: {
          args: Prisma.StockCremoraAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateStockCremora>
        }
        groupBy: {
          args: Prisma.StockCremoraGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StockCremoraGroupByOutputType>[]
        }
        count: {
          args: Prisma.StockCremoraCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StockCremoraCountAggregateOutputType> | number
        }
      }
    }
    sysdiagrams: {
      payload: Prisma.$sysdiagramsPayload<ExtArgs>
      fields: Prisma.sysdiagramsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.sysdiagramsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sysdiagramsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.sysdiagramsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
        }
        findFirst: {
          args: Prisma.sysdiagramsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sysdiagramsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.sysdiagramsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
        }
        findMany: {
          args: Prisma.sysdiagramsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sysdiagramsPayload>[]
        }
        create: {
          args: Prisma.sysdiagramsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
        }
        createMany: {
          args: Prisma.sysdiagramsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.sysdiagramsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
        }
        update: {
          args: Prisma.sysdiagramsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
        }
        deleteMany: {
          args: Prisma.sysdiagramsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.sysdiagramsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.sysdiagramsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
        }
        aggregate: {
          args: Prisma.SysdiagramsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSysdiagrams>
        }
        groupBy: {
          args: Prisma.sysdiagramsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SysdiagramsGroupByOutputType>[]
        }
        count: {
          args: Prisma.sysdiagramsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SysdiagramsCountAggregateOutputType> | number
        }
      }
    }
    tProperty: {
      payload: Prisma.$tPropertyPayload<ExtArgs>
      fields: Prisma.tPropertyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.tPropertyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$tPropertyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.tPropertyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$tPropertyPayload>
        }
        findFirst: {
          args: Prisma.tPropertyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$tPropertyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.tPropertyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$tPropertyPayload>
        }
        findMany: {
          args: Prisma.tPropertyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$tPropertyPayload>[]
        }
        create: {
          args: Prisma.tPropertyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$tPropertyPayload>
        }
        createMany: {
          args: Prisma.tPropertyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.tPropertyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$tPropertyPayload>
        }
        update: {
          args: Prisma.tPropertyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$tPropertyPayload>
        }
        deleteMany: {
          args: Prisma.tPropertyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.tPropertyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.tPropertyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$tPropertyPayload>
        }
        aggregate: {
          args: Prisma.TPropertyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTProperty>
        }
        groupBy: {
          args: Prisma.tPropertyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TPropertyGroupByOutputType>[]
        }
        count: {
          args: Prisma.tPropertyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TPropertyCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable',
  Snapshot: 'Snapshot'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const Conf_EOQSTOKScalarFieldEnum = {
  UPC: 'UPC',
  Description: 'Description',
  Stock_Minimo: 'Stock_Minimo'
} as const

export type Conf_EOQSTOKScalarFieldEnum = (typeof Conf_EOQSTOKScalarFieldEnum)[keyof typeof Conf_EOQSTOKScalarFieldEnum]


export const DAddressScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  AddressType: 'AddressType',
  AddressLink: 'AddressLink',
  AddressSource: 'AddressSource',
  AddressID: 'AddressID',
  AddressName: 'AddressName',
  Address1: 'Address1',
  Address2: 'Address2',
  Address3: 'Address3',
  Address4: 'Address4',
  City: 'City',
  State: 'State',
  Zip: 'Zip',
  Country: 'Country',
  Attention: 'Attention',
  Contact1: 'Contact1',
  Contact2: 'Contact2',
  Phone1: 'Phone1',
  Phone2: 'Phone2',
  Fax1: 'Fax1',
  Fax2: 'Fax2',
  Email1: 'Email1',
  Email2: 'Email2',
  URL1: 'URL1',
  URL2: 'URL2',
  UsePrimary: 'UsePrimary',
  UseLocation: 'UseLocation',
  UseShip: 'UseShip',
  UseBill: 'UseBill',
  UseMail: 'UseMail',
  UseOther: 'UseOther',
  IdentParent: 'IdentParent'
} as const

export type DAddressScalarFieldEnum = (typeof DAddressScalarFieldEnum)[keyof typeof DAddressScalarFieldEnum]


export const DChannelOrderScalarFieldEnum = {
  Identifier: 'Identifier',
  Channel: 'Channel'
} as const

export type DChannelOrderScalarFieldEnum = (typeof DChannelOrderScalarFieldEnum)[keyof typeof DChannelOrderScalarFieldEnum]


export const DCodeScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  CodeSequence: 'CodeSequence',
  CodeCategory: 'CodeCategory',
  CodeValue: 'CodeValue',
  CodeLink: 'CodeLink',
  CodeFlags: 'CodeFlags',
  CodeInteger: 'CodeInteger',
  CodeFloat: 'CodeFloat',
  CodeDate: 'CodeDate',
  CodeString: 'CodeString'
} as const

export type DCodeScalarFieldEnum = (typeof DCodeScalarFieldEnum)[keyof typeof DCodeScalarFieldEnum]


export const DCommandScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  Type: 'Type',
  Sequence: 'Sequence',
  Control: 'Control',
  Command: 'Command',
  Mode: 'Mode',
  Flags: 'Flags',
  Stage: 'Stage',
  SourceStage: 'SourceStage',
  SourceName: 'SourceName',
  HostName: 'HostName',
  CommandText: 'CommandText'
} as const

export type DCommandScalarFieldEnum = (typeof DCommandScalarFieldEnum)[keyof typeof DCommandScalarFieldEnum]


export const DControlScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  SiteName: 'SiteName',
  SerialNumber: 'SerialNumber',
  Subscription: 'Subscription',
  Name: 'Name',
  Plant: 'Plant',
  PlantType: 'PlantType',
  PlantID: 'PlantID',
  CFN: 'CFN',
  FDA: 'FDA',
  GS1: 'GS1',
  BranchWO: 'BranchWO',
  BranchTran: 'BranchTran',
  AirPort: 'AirPort',
  Timeout: 'Timeout',
  SortFile: 'SortFile',
  ShipFile: 'ShipFile',
  ShipAccount: 'ShipAccount',
  PortName: 'PortName',
  Season: 'Season',
  IdentAddressLocation: 'IdentAddressLocation',
  IdentAddressBill: 'IdentAddressBill',
  IdentAddressShip: 'IdentAddressShip',
  SerialNext: 'SerialNext',
  PalletNext: 'PalletNext',
  ERPNext: 'ERPNext',
  BLNext: 'BLNext',
  SerialLength: 'SerialLength',
  PalletLength: 'PalletLength',
  PalletWeight: 'PalletWeight',
  BoxWeight: 'BoxWeight',
  TierSize: 'TierSize',
  SerialTare: 'SerialTare',
  Interval: 'Interval',
  Frequency: 'Frequency',
  Location: 'Location',
  DatePref: 'DatePref',
  ReboxPref: 'ReboxPref',
  ReboxMethod: 'ReboxMethod',
  Password: 'Password',
  SelfStrip: 'SelfStrip',
  Palletize: 'Palletize',
  PalletDups: 'PalletDups',
  AutoProc: 'AutoProc',
  AddScanned: 'AddScanned',
  PrepDate: 'PrepDate',
  Reindex: 'Reindex',
  ColdStore: 'ColdStore',
  Depth: 'Depth',
  Julian: 'Julian',
  Metric: 'Metric',
  Network: 'Network',
  Mail: 'Mail',
  FTP: 'FTP',
  ERP: 'ERP'
} as const

export type DControlScalarFieldEnum = (typeof DControlScalarFieldEnum)[keyof typeof DControlScalarFieldEnum]


export const DCustomerScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  CustomerID: 'CustomerID',
  CustomerName: 'CustomerName',
  Transfer: 'Transfer',
  StockLabel: 'StockLabel',
  PalletLabel: 'PalletLabel',
  LabelPrefix: 'LabelPrefix',
  Route: 'Route',
  IdentAddress: 'IdentAddress',
  ExternalID: 'ExternalID',
  UsePrimary: 'UsePrimary',
  UseLocation: 'UseLocation',
  UseShip: 'UseShip',
  UseBill: 'UseBill',
  UseMail: 'UseMail',
  UseOther: 'UseOther',
  IdentParent: 'IdentParent'
} as const

export type DCustomerScalarFieldEnum = (typeof DCustomerScalarFieldEnum)[keyof typeof DCustomerScalarFieldEnum]


export const DDataScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  DataClass: 'DataClass',
  DataName: 'DataName',
  Sequence: 'Sequence',
  IntegerValue: 'IntegerValue',
  FloatValue: 'FloatValue',
  DateTimeValue: 'DateTimeValue',
  StringValue: 'StringValue'
} as const

export type DDataScalarFieldEnum = (typeof DDataScalarFieldEnum)[keyof typeof DDataScalarFieldEnum]


export const DDepthScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  Type: 'Type',
  Season: 'Season',
  Serial: 'Serial',
  Field: 'Field',
  Data: 'Data',
  Weight: 'Weight',
  Quantity: 'Quantity',
  Void: 'Void',
  Deleted: 'Deleted',
  AddDate: 'AddDate',
  ExpDate: 'ExpDate',
  IdentStock: 'IdentStock',
  IdentStorage: 'IdentStorage'
} as const

export type DDepthScalarFieldEnum = (typeof DDepthScalarFieldEnum)[keyof typeof DDepthScalarFieldEnum]


export const DERPScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  TranCode: 'TranCode',
  TranStatus: 'TranStatus',
  Product: 'Product',
  ItemCode: 'ItemCode',
  Serial: 'Serial',
  Lot: 'Lot',
  Weight: 'Weight',
  Quantity: 'Quantity',
  UOM: 'UOM',
  StorageFrom: 'StorageFrom',
  StorageTo: 'StorageTo',
  Vendor: 'Vendor',
  Customer: 'Customer',
  OrderNumber: 'OrderNumber',
  PurchaseOrder: 'PurchaseOrder',
  SalesOrder: 'SalesOrder',
  WorkOrder: 'WorkOrder',
  TransferOrder: 'TransferOrder',
  BLSequence: 'BLSequence',
  Rate: 'Rate',
  BestBuyDate: 'BestBuyDate',
  Origin: 'Origin',
  TransferDate: 'TransferDate',
  TransferStamp: 'TransferStamp',
  Message: 'Message',
  ERPStamp: 'ERPStamp',
  ExternalIDSales: 'ExternalIDSales',
  ExternalIDTrans: 'ExternalIDTrans',
  ExternalIDFull: 'ExternalIDFull',
  ExternalIDAsm: 'ExternalIDAsm'
} as const

export type DERPScalarFieldEnum = (typeof DERPScalarFieldEnum)[keyof typeof DERPScalarFieldEnum]


export const DMetaScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  Sequence: 'Sequence',
  Type: 'Type',
  Field: 'Field',
  Kind: 'Kind',
  Width: 'Width',
  Places: 'Places',
  Display: 'Display',
  Code: 'Code',
  Activity: 'Activity',
  Title: 'Title',
  Position: 'Position',
  Setup: 'Setup',
  Class: 'Class',
  PropertyField: 'PropertyField',
  ProductField: 'ProductField',
  SetupField: 'SetupField',
  LongField: 'LongField',
  TableName: 'TableName',
  Operation: 'Operation'
} as const

export type DMetaScalarFieldEnum = (typeof DMetaScalarFieldEnum)[keyof typeof DMetaScalarFieldEnum]


export const DOrderScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  OrderNumber: 'OrderNumber',
  ImportDate: 'ImportDate',
  ExportDate: 'ExportDate',
  ExternalID: 'ExternalID',
  OrderType: 'OrderType',
  Seal: 'Seal',
  Carrier: 'Carrier',
  LoadDate: 'LoadDate',
  ShipDate: 'ShipDate',
  Department: 'Department',
  Insurance: 'Insurance',
  CatchArea: 'CatchArea',
  Vessel: 'Vessel',
  Voyage: 'Voyage',
  Mawb: 'Mawb',
  Awb: 'Awb',
  PortName: 'PortName',
  PortDispatcher: 'PortDispatcher',
  Destination: 'Destination',
  BoxSize: 'BoxSize',
  BoxTare: 'BoxTare',
  ToteTare: 'ToteTare',
  Transfer: 'Transfer',
  Rebox: 'Rebox',
  BLType: 'BLType',
  BLNumber: 'BLNumber',
  BLSequence: 'BLSequence',
  PLType: 'PLType',
  PLNumber: 'PLNumber',
  PLSequence: 'PLSequence',
  ExportNumber: 'ExportNumber',
  Booking: 'Booking',
  ControlNumber: 'ControlNumber',
  Processor: 'Processor',
  Collect: 'Collect',
  Inspect: 'Inspect',
  BeyondCarrier: 'BeyondCarrier',
  SetTemp: 'SetTemp',
  DepartTemp: 'DepartTemp',
  RecordBy: 'RecordBy',
  SignBy: 'SignBy',
  Priority: 'Priority',
  NSI: 'NSI',
  Flight: 'Flight',
  Handling1: 'Handling1',
  Handling2: 'Handling2',
  QualityControl: 'QualityControl',
  PRO: 'PRO',
  SPI: 'SPI',
  Shipment: 'Shipment',
  Brand: 'Brand',
  Commodity: 'Commodity',
  PalletsOut: 'PalletsOut',
  PalletType: 'PalletType',
  Bay: 'Bay',
  Container: 'Container',
  DateTaken: 'DateTaken',
  DateExpected: 'DateExpected',
  Date1: 'Date1',
  Date2: 'Date2',
  Date3: 'Date3',
  Date4: 'Date4',
  Text1: 'Text1',
  Text2: 'Text2',
  IdentCustomer: 'IdentCustomer',
  IdentStorage: 'IdentStorage',
  IdentAddressLocation: 'IdentAddressLocation',
  IdentAddressBill: 'IdentAddressBill',
  IdentAddressShip: 'IdentAddressShip',
  IdentAddressShipper: 'IdentAddressShipper',
  IdentAddressCarrier: 'IdentAddressCarrier',
  IdentAddressDestination: 'IdentAddressDestination',
  IdentAddressDistribution: 'IdentAddressDistribution',
  LoadDateOnly: 'LoadDateOnly',
  ShipDateOnly: 'ShipDateOnly'
} as const

export type DOrderScalarFieldEnum = (typeof DOrderScalarFieldEnum)[keyof typeof DOrderScalarFieldEnum]


export const DPageScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  PageNumber: 'PageNumber',
  PageTitle: 'PageTitle',
  Title: 'Title',
  Name: 'Name',
  BarCode: 'BarCode',
  Stations: 'Stations',
  Flags: 'Flags',
  IsDefault: 'IsDefault',
  IdentProperty: 'IdentProperty'
} as const

export type DPageScalarFieldEnum = (typeof DPageScalarFieldEnum)[keyof typeof DPageScalarFieldEnum]


export const DProductScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  Product: 'Product',
  ItemCode: 'ItemCode',
  ProductKey: 'ProductKey',
  PropertyGroup: 'PropertyGroup',
  Description: 'Description',
  Description2: 'Description2',
  Description3: 'Description3',
  UPC: 'UPC',
  GTIN: 'GTIN',
  GS1: 'GS1',
  PLU: 'PLU',
  IMP: 'IMP',
  NAMP: 'NAMP',
  SeasonType: 'SeasonType',
  PageTitle: 'PageTitle',
  StockLabel: 'StockLabel',
  PalletLabel: 'PalletLabel',
  Picked: 'Picked',
  ReqRebox: 'ReqRebox',
  HoldCode: 'HoldCode',
  Plants: 'Plants',
  Class: 'Class',
  UOM: 'UOM',
  PackUnit: 'PackUnit',
  BreakUnit: 'BreakUnit',
  BreakNumber: 'BreakNumber',
  SizeUnit: 'SizeUnit',
  SizeNumber: 'SizeNumber',
  SizeQuantity: 'SizeQuantity',
  ERPExempt: 'ERPExempt',
  IdentStorage: 'IdentStorage',
  ExternalID: 'ExternalID'
} as const

export type DProductScalarFieldEnum = (typeof DProductScalarFieldEnum)[keyof typeof DProductScalarFieldEnum]


export const DProductPropertyScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  IdentProduct: 'IdentProduct',
  IdentProperty: 'IdentProperty',
  IdentMeta: 'IdentMeta',
  Product: 'Product',
  Title: 'Title',
  Name: 'Name',
  Short: 'Short',
  Barcode: 'Barcode',
  Flags: 'Flags',
  Misc: 'Misc'
} as const

export type DProductPropertyScalarFieldEnum = (typeof DProductPropertyScalarFieldEnum)[keyof typeof DProductPropertyScalarFieldEnum]


export const DProductPropertyPivotScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  IdentProduct: 'IdentProduct',
  Product: 'Product',
  UpdateFlag: 'UpdateFlag',
  IdentProductPropertySPECIES: 'IdentProductPropertySPECIES',
  IdentProductPropertyCUT: 'IdentProductPropertyCUT',
  IdentProductPropertyTYPE: 'IdentProductPropertyTYPE',
  IdentProductPropertyFORM: 'IdentProductPropertyFORM',
  IdentProductPropertySIZE: 'IdentProductPropertySIZE',
  IdentProductPropertyGAS: 'IdentProductPropertyGAS',
  IdentProductPropertyINVENTORY: 'IdentProductPropertyINVENTORY',
  IdentPropertySPECIES: 'IdentPropertySPECIES',
  IdentPropertyCUT: 'IdentPropertyCUT',
  IdentPropertyTYPE: 'IdentPropertyTYPE',
  IdentPropertyFORM: 'IdentPropertyFORM',
  IdentPropertySIZE: 'IdentPropertySIZE',
  IdentPropertyGAS: 'IdentPropertyGAS',
  IdentPropertyINVENTORY: 'IdentPropertyINVENTORY',
  NameSPECIES: 'NameSPECIES',
  NameCUT: 'NameCUT',
  NameTYPE: 'NameTYPE',
  NameFORM: 'NameFORM',
  NameSIZE: 'NameSIZE',
  NameGAS: 'NameGAS',
  NameINVENTORY: 'NameINVENTORY',
  ShortSPECIES: 'ShortSPECIES',
  ShortCUT: 'ShortCUT',
  ShortTYPE: 'ShortTYPE',
  ShortFORM: 'ShortFORM',
  ShortSIZE: 'ShortSIZE',
  ShortGAS: 'ShortGAS',
  ShortINVENTORY: 'ShortINVENTORY',
  BarcodeSPECIES: 'BarcodeSPECIES',
  BarcodeCUT: 'BarcodeCUT',
  BarcodeTYPE: 'BarcodeTYPE',
  BarcodeFORM: 'BarcodeFORM',
  BarcodeSIZE: 'BarcodeSIZE',
  BarcodeGAS: 'BarcodeGAS',
  BarcodeINVENTORY: 'BarcodeINVENTORY'
} as const

export type DProductPropertyPivotScalarFieldEnum = (typeof DProductPropertyPivotScalarFieldEnum)[keyof typeof DProductPropertyPivotScalarFieldEnum]


export const DPropertyScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  Field: 'Field',
  Title: 'Title',
  Name: 'Name',
  Short: 'Short',
  Barcode: 'Barcode',
  Flags: 'Flags',
  Misc: 'Misc',
  Quantity: 'Quantity',
  NetWeight: 'NetWeight',
  GrossWeight: 'GrossWeight',
  TareWeight: 'TareWeight',
  CanWeight: 'CanWeight',
  CaseSize: 'CaseSize',
  Latin: 'Latin',
  English: 'English',
  Spanish: 'Spanish',
  French: 'French',
  Japanese: 'Japanese',
  Hebrew: 'Hebrew',
  Chinese: 'Chinese',
  Lang7: 'Lang7',
  Lang8: 'Lang8',
  ExternalID: 'ExternalID'
} as const

export type DPropertyScalarFieldEnum = (typeof DPropertyScalarFieldEnum)[keyof typeof DPropertyScalarFieldEnum]


export const DPurchaseOrderScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  PurchaseOrder: 'PurchaseOrder',
  ImportDate: 'ImportDate',
  ExportDate: 'ExportDate',
  ExternalID: 'ExternalID',
  LineID: 'LineID',
  CommitID: 'CommitID',
  ItemID: 'ItemID',
  Type: 'Type',
  Line: 'Line',
  ItemNumber: 'ItemNumber',
  Quantity: 'Quantity',
  QuantityCommit: 'QuantityCommit',
  UOM: 'UOM',
  UOMCommit: 'UOMCommit',
  Weight: 'Weight',
  UOMWeight: 'UOMWeight',
  Lot: 'Lot',
  Storage: 'Storage',
  StorageTo: 'StorageTo',
  Initial: 'Initial',
  Expected: 'Expected',
  Committed: 'Committed',
  Completed: 'Completed',
  Supplier: 'Supplier',
  Customer: 'Customer',
  Owner: 'Owner',
  IdentProduct: 'IdentProduct',
  IdentStorage: 'IdentStorage',
  IdentStorageTo: 'IdentStorageTo',
  IdentSupplier: 'IdentSupplier',
  IdentCustomer: 'IdentCustomer',
  IdentAddressLocation: 'IdentAddressLocation',
  IdentAddressBill: 'IdentAddressBill',
  IdentAddressShip: 'IdentAddressShip'
} as const

export type DPurchaseOrderScalarFieldEnum = (typeof DPurchaseOrderScalarFieldEnum)[keyof typeof DPurchaseOrderScalarFieldEnum]


export const DSalesOrderScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  SalesOrder: 'SalesOrder',
  ImportDate: 'ImportDate',
  ExportDate: 'ExportDate',
  ExternalID: 'ExternalID',
  LineID: 'LineID',
  CommitID: 'CommitID',
  ItemID: 'ItemID',
  Type: 'Type',
  Line: 'Line',
  ItemNumber: 'ItemNumber',
  Quantity: 'Quantity',
  QuantityCommit: 'QuantityCommit',
  UOM: 'UOM',
  UOMCommit: 'UOMCommit',
  Weight: 'Weight',
  UOMWeight: 'UOMWeight',
  Lot: 'Lot',
  Storage: 'Storage',
  StorageTo: 'StorageTo',
  Initial: 'Initial',
  Expected: 'Expected',
  Committed: 'Committed',
  Completed: 'Completed',
  PurchaseOrder: 'PurchaseOrder',
  Customer: 'Customer',
  Owner: 'Owner',
  IdentProduct: 'IdentProduct',
  IdentStorage: 'IdentStorage',
  IdentStorageTo: 'IdentStorageTo',
  IdentCustomer: 'IdentCustomer',
  IdentAddressLocation: 'IdentAddressLocation',
  IdentAddressBill: 'IdentAddressBill',
  IdentAddressShip: 'IdentAddressShip',
  IdentAddressShipper: 'IdentAddressShipper',
  IdentAddressCarrier: 'IdentAddressCarrier',
  IdentAddressDestination: 'IdentAddressDestination',
  IdentAddressDistribution: 'IdentAddressDistribution'
} as const

export type DSalesOrderScalarFieldEnum = (typeof DSalesOrderScalarFieldEnum)[keyof typeof DSalesOrderScalarFieldEnum]


export const DStationScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  StationType: 'StationType',
  StationID: 'StationID',
  StationName: 'StationName',
  StationMachine: 'StationMachine',
  StationMenu: 'StationMenu',
  StationNumber: 'StationNumber',
  StationIP: 'StationIP',
  StationPort: 'StationPort',
  IdentAddress: 'IdentAddress',
  LotCode: 'LotCode',
  TransferProgram: 'TransferProgram',
  TransferTable: 'TransferTable',
  Comment1: 'Comment1',
  Comment2: 'Comment2',
  Comment3: 'Comment3',
  Comment4: 'Comment4',
  Comment5: 'Comment5',
  Comment6: 'Comment6'
} as const

export type DStationScalarFieldEnum = (typeof DStationScalarFieldEnum)[keyof typeof DStationScalarFieldEnum]


export const DStockScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  TranCode: 'TranCode',
  TranYear: 'TranYear',
  Season: 'Season',
  Plant: 'Plant',
  Serial: 'Serial',
  Pallet: 'Pallet',
  Lot: 'Lot',
  Source: 'Source',
  Void: 'Void',
  Split: 'Split',
  Rebox: 'Rebox',
  Remake: 'Remake',
  UseCount: 'UseCount',
  Edited: 'Edited',
  IdentAddressCustomer: 'IdentAddressCustomer',
  IdentAddressVendor: 'IdentAddressVendor',
  IdentProduct: 'IdentProduct',
  IdentOrder: 'IdentOrder',
  IdentPurchaseOrder: 'IdentPurchaseOrder',
  IdentSalesOrder: 'IdentSalesOrder',
  IdentWorkOrder: 'IdentWorkOrder',
  IdentTransferOrder: 'IdentTransferOrder',
  IdentStation: 'IdentStation',
  IdentStorage: 'IdentStorage',
  IdentPackage: 'IdentPackage',
  IdentStage: 'IdentStage',
  IdentNetSource: 'IdentNetSource',
  IdentGrossSource: 'IdentGrossSource',
  IdentTareSource: 'IdentTareSource',
  IdentGelSource: 'IdentGelSource',
  IdentVacSource: 'IdentVacSource',
  IdentGlazeSource: 'IdentGlazeSource',
  IdentLiveSource: 'IdentLiveSource',
  IdentHotSource: 'IdentHotSource',
  IdentColdSource: 'IdentColdSource',
  IdentTargetSource: 'IdentTargetSource',
  IdentWeightASource: 'IdentWeightASource',
  IdentWeightBSource: 'IdentWeightBSource',
  OrigWeight: 'OrigWeight',
  NetWeight: 'NetWeight',
  GrossWeight: 'GrossWeight',
  TareWeight: 'TareWeight',
  GelWeight: 'GelWeight',
  VacWeight: 'VacWeight',
  GlazeWeight: 'GlazeWeight',
  LiveWeight: 'LiveWeight',
  HotWeight: 'HotWeight',
  ColdWeight: 'ColdWeight',
  TargetWeight: 'TargetWeight',
  WeightA: 'WeightA',
  WeightB: 'WeightB',
  OrigQuantity: 'OrigQuantity',
  Quantity: 'Quantity',
  UnitsQuantity: 'UnitsQuantity',
  UnitsUOM: 'UnitsUOM',
  UOM: 'UOM',
  HarvestDate: 'HarvestDate',
  PrepDate: 'PrepDate',
  PackDate: 'PackDate',
  LoadDate: 'LoadDate',
  ShipDate: 'ShipDate',
  BuyDate: 'BuyDate',
  UploadDate: 'UploadDate',
  EditDate: 'EditDate',
  Glaze: 'Glaze',
  GelPak: 'GelPak',
  Julian: 'Julian',
  PalletLabel: 'PalletLabel',
  StockLabel: 'StockLabel',
  GS1Barcode: 'GS1Barcode',
  AIN: 'AIN',
  Tag: 'Tag',
  Temperature: 'Temperature',
  Quality: 'Quality',
  LabelNumber: 'LabelNumber',
  Reference: 'Reference',
  Note: 'Note',
  Cost: 'Cost',
  TransferSource: 'TransferSource',
  TransferStamp: 'TransferStamp',
  ERPStamp: 'ERPStamp',
  ExportDate: 'ExportDate',
  ImportDate: 'ImportDate',
  ExternalID: 'ExternalID',
  PurchaseOrderText: 'PurchaseOrderText',
  OrderNumberText: 'OrderNumberText',
  HarvestDateOnly: 'HarvestDateOnly',
  PrepDateOnly: 'PrepDateOnly',
  PackDateOnly: 'PackDateOnly',
  LoadDateOnly: 'LoadDateOnly',
  ShipDateOnly: 'ShipDateOnly',
  BuyDateOnly: 'BuyDateOnly',
  UploadDateOnly: 'UploadDateOnly',
  EditDateOnly: 'EditDateOnly'
} as const

export type DStockScalarFieldEnum = (typeof DStockScalarFieldEnum)[keyof typeof DStockScalarFieldEnum]


export const DStockAuditScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  TranCode: 'TranCode',
  StorageID: 'StorageID',
  Serial: 'Serial',
  Pallet: 'Pallet',
  Weight: 'Weight',
  Quantity: 'Quantity',
  WeightActual: 'WeightActual',
  QuantityActual: 'QuantityActual',
  RecordDate: 'RecordDate',
  GS1Barcode: 'GS1Barcode',
  IdentStock: 'IdentStock',
  IdentStorage: 'IdentStorage'
} as const

export type DStockAuditScalarFieldEnum = (typeof DStockAuditScalarFieldEnum)[keyof typeof DStockAuditScalarFieldEnum]


export const DStockPropertyScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  IdentStock: 'IdentStock',
  IdentProperty: 'IdentProperty',
  IdentMeta: 'IdentMeta',
  Serial: 'Serial',
  Title: 'Title',
  Name: 'Name',
  Short: 'Short',
  Barcode: 'Barcode',
  Flags: 'Flags',
  Misc: 'Misc'
} as const

export type DStockPropertyScalarFieldEnum = (typeof DStockPropertyScalarFieldEnum)[keyof typeof DStockPropertyScalarFieldEnum]


export const DStockPropertyPivotScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  IdentStock: 'IdentStock',
  Serial: 'Serial',
  UpdateFlag: 'UpdateFlag',
  IdentStockPropertyGEAR: 'IdentStockPropertyGEAR',
  IdentStockPropertyGRADE: 'IdentStockPropertyGRADE',
  IdentStockPropertyCONDITION: 'IdentStockPropertyCONDITION',
  IdentStockPropertyPACKAGE: 'IdentStockPropertyPACKAGE',
  IdentStockPropertyBOAT: 'IdentStockPropertyBOAT',
  IdentStockPropertyUSER: 'IdentStockPropertyUSER',
  IdentStockPropertyPORT: 'IdentStockPropertyPORT',
  IdentStockPropertyALLERGY: 'IdentStockPropertyALLERGY',
  IdentPropertyGEAR: 'IdentPropertyGEAR',
  IdentPropertyGRADE: 'IdentPropertyGRADE',
  IdentPropertyCONDITION: 'IdentPropertyCONDITION',
  IdentPropertyPACKAGE: 'IdentPropertyPACKAGE',
  IdentPropertyBOAT: 'IdentPropertyBOAT',
  IdentPropertyUSER: 'IdentPropertyUSER',
  IdentPropertyPORT: 'IdentPropertyPORT',
  IdentPropertyALLERGY: 'IdentPropertyALLERGY',
  NameGEAR: 'NameGEAR',
  NameGRADE: 'NameGRADE',
  NameCONDITION: 'NameCONDITION',
  NamePACKAGE: 'NamePACKAGE',
  NameBOAT: 'NameBOAT',
  NameUSER: 'NameUSER',
  NamePORT: 'NamePORT',
  NameALLERGY: 'NameALLERGY',
  ShortGEAR: 'ShortGEAR',
  ShortGRADE: 'ShortGRADE',
  ShortCONDITION: 'ShortCONDITION',
  ShortPACKAGE: 'ShortPACKAGE',
  ShortBOAT: 'ShortBOAT',
  ShortUSER: 'ShortUSER',
  ShortPORT: 'ShortPORT',
  ShortALLERGY: 'ShortALLERGY',
  BarcodeGEAR: 'BarcodeGEAR',
  BarcodeGRADE: 'BarcodeGRADE',
  BarcodeCONDITION: 'BarcodeCONDITION',
  BarcodePACKAGE: 'BarcodePACKAGE',
  BarcodeBOAT: 'BarcodeBOAT',
  BarcodeUSER: 'BarcodeUSER',
  BarcodePORT: 'BarcodePORT',
  BarcodeALLERGY: 'BarcodeALLERGY'
} as const

export type DStockPropertyPivotScalarFieldEnum = (typeof DStockPropertyPivotScalarFieldEnum)[keyof typeof DStockPropertyPivotScalarFieldEnum]


export const DStorageScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  StorageID: 'StorageID',
  StorageName: 'StorageName',
  Description: 'Description',
  Minimum: 'Minimum',
  Maximum: 'Maximum',
  IdentParent: 'IdentParent',
  IdentAddressLocation: 'IdentAddressLocation',
  IdentAddressShip: 'IdentAddressShip'
} as const

export type DStorageScalarFieldEnum = (typeof DStorageScalarFieldEnum)[keyof typeof DStorageScalarFieldEnum]


export const DSupplierScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  SupplierID: 'SupplierID',
  SupplierName: 'SupplierName',
  IdentAddress: 'IdentAddress',
  ExternalID: 'ExternalID'
} as const

export type DSupplierScalarFieldEnum = (typeof DSupplierScalarFieldEnum)[keyof typeof DSupplierScalarFieldEnum]


export const DSyncScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  SyncName: 'SyncName',
  DateTimeUpdate: 'DateTimeUpdate'
} as const

export type DSyncScalarFieldEnum = (typeof DSyncScalarFieldEnum)[keyof typeof DSyncScalarFieldEnum]


export const DTextScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  TextLanguage: 'TextLanguage',
  TextSequence: 'TextSequence',
  TextCategory: 'TextCategory',
  TextName: 'TextName',
  TextName2: 'TextName2',
  TextNumber: 'TextNumber',
  TextString: 'TextString',
  TextString2: 'TextString2'
} as const

export type DTextScalarFieldEnum = (typeof DTextScalarFieldEnum)[keyof typeof DTextScalarFieldEnum]


export const DTransferOrderScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  TransferOrder: 'TransferOrder',
  ImportDate: 'ImportDate',
  ExportDate: 'ExportDate',
  ExternalID: 'ExternalID',
  LineID: 'LineID',
  CommitID: 'CommitID',
  ItemID: 'ItemID',
  ItemIDTO: 'ItemIDTO',
  Type: 'Type',
  Line: 'Line',
  ItemNumber: 'ItemNumber',
  ItemNumberTo: 'ItemNumberTo',
  Quantity: 'Quantity',
  QuantityCommit: 'QuantityCommit',
  QuantityReceived: 'QuantityReceived',
  QuantityShipped: 'QuantityShipped',
  UOM: 'UOM',
  UOMCommit: 'UOMCommit',
  UOMReceived: 'UOMReceived',
  UOMShipped: 'UOMShipped',
  Weight: 'Weight',
  UOMWeight: 'UOMWeight',
  Lot: 'Lot',
  LotFrom: 'LotFrom',
  LotTo: 'LotTo',
  Storage: 'Storage',
  StorageTo: 'StorageTo',
  Initial: 'Initial',
  Expected: 'Expected',
  Committed: 'Committed',
  Completed: 'Completed',
  Company: 'Company',
  Owner: 'Owner',
  IdentProduct: 'IdentProduct',
  IdentStorage: 'IdentStorage',
  IdentStorageTo: 'IdentStorageTo',
  IdentCompany: 'IdentCompany'
} as const

export type DTransferOrderScalarFieldEnum = (typeof DTransferOrderScalarFieldEnum)[keyof typeof DTransferOrderScalarFieldEnum]


export const DUserScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  UserID: 'UserID',
  UserName: 'UserName',
  UserNameOS: 'UserNameOS',
  UserLevel: 'UserLevel',
  Operator: 'Operator',
  Station: 'Station',
  IsLocked: 'IsLocked',
  CrashFlag: 'CrashFlag',
  CrashFile: 'CrashFile',
  CrashDate: 'CrashDate',
  FlagX: 'FlagX',
  FlagY: 'FlagY'
} as const

export type DUserScalarFieldEnum = (typeof DUserScalarFieldEnum)[keyof typeof DUserScalarFieldEnum]


export const DVendorScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  VendorID: 'VendorID',
  VendorName: 'VendorName',
  IdentAddress: 'IdentAddress',
  ExternalID: 'ExternalID',
  UsePrimary: 'UsePrimary',
  UseLocation: 'UseLocation',
  UseShip: 'UseShip',
  UseBill: 'UseBill',
  UseMail: 'UseMail',
  UseOther: 'UseOther',
  IdentParent: 'IdentParent'
} as const

export type DVendorScalarFieldEnum = (typeof DVendorScalarFieldEnum)[keyof typeof DVendorScalarFieldEnum]


export const DWorkOrderScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  WorkOrder: 'WorkOrder',
  ImportDate: 'ImportDate',
  ExportDate: 'ExportDate',
  ExternalID: 'ExternalID',
  LineID: 'LineID',
  CommitID: 'CommitID',
  ItemID: 'ItemID',
  FGID: 'FGID',
  RMID: 'RMID',
  Type: 'Type',
  Line: 'Line',
  ItemNumber: 'ItemNumber',
  Quantity: 'Quantity',
  QuantityCommit: 'QuantityCommit',
  UOM: 'UOM',
  UOMCommit: 'UOMCommit',
  Weight: 'Weight',
  UOMWeight: 'UOMWeight',
  Lot: 'Lot',
  Storage: 'Storage',
  StorageTo: 'StorageTo',
  Initial: 'Initial',
  Committed: 'Committed',
  Completed: 'Completed',
  Package: 'Package',
  Company: 'Company',
  Owner: 'Owner',
  IdentProduct: 'IdentProduct',
  IdentStorage: 'IdentStorage',
  IdentStorageTo: 'IdentStorageTo',
  IdentCompany: 'IdentCompany'
} as const

export type DWorkOrderScalarFieldEnum = (typeof DWorkOrderScalarFieldEnum)[keyof typeof DWorkOrderScalarFieldEnum]


export const ItemSageScalarFieldEnum = {
  Identifier: 'Identifier',
  Item_ID: 'Item_ID',
  Item_Description: 'Item_Description'
} as const

export type ItemSageScalarFieldEnum = (typeof ItemSageScalarFieldEnum)[keyof typeof ItemSageScalarFieldEnum]


export const SageNameScalarFieldEnum = {
  Indentifier: 'Indentifier',
  SageID: 'SageID',
  SageName: 'SageName',
  IdentVendor: 'IdentVendor',
  IdentAddressName: 'IdentAddressName',
  IdentAttention: 'IdentAttention'
} as const

export type SageNameScalarFieldEnum = (typeof SageNameScalarFieldEnum)[keyof typeof SageNameScalarFieldEnum]


export const SageVendorScalarFieldEnum = {
  Identifier: 'Identifier',
  VendorID: 'VendorID',
  VendorName: 'VendorName'
} as const

export type SageVendorScalarFieldEnum = (typeof SageVendorScalarFieldEnum)[keyof typeof SageVendorScalarFieldEnum]


export const SessionsScalarFieldEnum = {
  sid: 'sid',
  session: 'session',
  expires: 'expires'
} as const

export type SessionsScalarFieldEnum = (typeof SessionsScalarFieldEnum)[keyof typeof SessionsScalarFieldEnum]


export const StockCremoraScalarFieldEnum = {
  ID: 'ID',
  IdentItem: 'IdentItem',
  Estado: 'Estado',
  Shipdate: 'Shipdate',
  Buydate: 'Buydate'
} as const

export type StockCremoraScalarFieldEnum = (typeof StockCremoraScalarFieldEnum)[keyof typeof StockCremoraScalarFieldEnum]


export const SysdiagramsScalarFieldEnum = {
  name: 'name',
  principal_id: 'principal_id',
  diagram_id: 'diagram_id',
  version: 'version',
  definition: 'definition'
} as const

export type SysdiagramsScalarFieldEnum = (typeof SysdiagramsScalarFieldEnum)[keyof typeof SysdiagramsScalarFieldEnum]


export const TPropertyScalarFieldEnum = {
  Identifier: 'Identifier',
  Status: 'Status',
  Creation: 'Creation',
  CreationID: 'CreationID',
  Maintenance: 'Maintenance',
  MaintenanceID: 'MaintenanceID',
  Field: 'Field',
  Title: 'Title',
  Name: 'Name',
  Short: 'Short',
  Barcode: 'Barcode',
  Flags: 'Flags',
  Misc: 'Misc',
  IntValue1: 'IntValue1',
  IntValue2: 'IntValue2',
  IntValue3: 'IntValue3',
  FloatValue1: 'FloatValue1',
  FloatValue2: 'FloatValue2',
  FloatValue3: 'FloatValue3',
  StringValue1: 'StringValue1',
  StringValue2: 'StringValue2',
  StringValue3: 'StringValue3',
  Chinese: 'Chinese',
  Latin: 'Latin',
  Japanese: 'Japanese',
  Hebrew: 'Hebrew',
  Lang5: 'Lang5',
  Lang6: 'Lang6',
  Lang7: 'Lang7',
  Lang8: 'Lang8',
  IdentMeta: 'IdentMeta',
  SortOrder: 'SortOrder'
} as const

export type TPropertyScalarFieldEnum = (typeof TPropertyScalarFieldEnum)[keyof typeof TPropertyScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'Decimal'
 */
export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'BigInt'
 */
export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


/**
 * Reference to a field of type 'Bytes'
 */
export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[]
}
export type GlobalOmitConfig = {
  conf_EOQSTOK?: Prisma.Conf_EOQSTOKOmit
  dAddress?: Prisma.dAddressOmit
  dChannelOrder?: Prisma.dChannelOrderOmit
  dCode?: Prisma.dCodeOmit
  dCommand?: Prisma.dCommandOmit
  dControl?: Prisma.dControlOmit
  dCustomer?: Prisma.dCustomerOmit
  dData?: Prisma.dDataOmit
  dDepth?: Prisma.dDepthOmit
  dERP?: Prisma.dERPOmit
  dMeta?: Prisma.dMetaOmit
  dOrder?: Prisma.dOrderOmit
  dPage?: Prisma.dPageOmit
  dProduct?: Prisma.dProductOmit
  dProductProperty?: Prisma.dProductPropertyOmit
  dProductPropertyPivot?: Prisma.dProductPropertyPivotOmit
  dProperty?: Prisma.dPropertyOmit
  dPurchaseOrder?: Prisma.dPurchaseOrderOmit
  dSalesOrder?: Prisma.dSalesOrderOmit
  dStation?: Prisma.dStationOmit
  dStock?: Prisma.dStockOmit
  dStockAudit?: Prisma.dStockAuditOmit
  dStockProperty?: Prisma.dStockPropertyOmit
  dStockPropertyPivot?: Prisma.dStockPropertyPivotOmit
  dStorage?: Prisma.dStorageOmit
  dSupplier?: Prisma.dSupplierOmit
  dSync?: Prisma.dSyncOmit
  dText?: Prisma.dTextOmit
  dTransferOrder?: Prisma.dTransferOrderOmit
  dUser?: Prisma.dUserOmit
  dVendor?: Prisma.dVendorOmit
  dWorkOrder?: Prisma.dWorkOrderOmit
  itemSage?: Prisma.ItemSageOmit
  sageName?: Prisma.SageNameOmit
  sageVendor?: Prisma.SageVendorOmit
  sessions?: Prisma.sessionsOmit
  stockCremora?: Prisma.StockCremoraOmit
  sysdiagrams?: Prisma.sysdiagramsOmit
  tProperty?: Prisma.tPropertyOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

